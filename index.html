<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Análisis Unificado de Arquitecturas de Sistemas Operativos</title>
    
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <style>
        :root {
            --bg-dark: #111827;
            --bg-card: rgba(31, 41, 55, 0.5);
            --border-color: rgba(75, 85, 99, 0.5);
            --text-light: #f3f4f6;
            --text-muted: #9ca3af;
            --accent-blue: #3b82f6;
            --accent-green: #22c55e;
            --accent-red: #ef4444;
            --accent-amber: #f59e0b;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            scroll-behavior: smooth;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-dark);
            color: var(--text-light);
            line-height: 1.7;
        }

        /* --- Encabezado y Navegación --- */
        header {
            position: sticky;
            top: 0;
            z-index: 1000;
            background-color: rgba(17, 24, 39, 0.8);
            backdrop-filter: blur(10px);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            border-bottom: 1px solid var(--border-color);
        }

        nav {
            display: flex;
            justify-content: center;
            align-items: center;
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 1rem;
            flex-wrap: wrap;
        }

        .nav-link {
            padding: 1rem 1.5rem;
            text-decoration: none;
            color: var(--text-muted);
            font-weight: 600;
            transition: color 0.3s, border-bottom-color 0.3s;
            border-bottom: 3px solid transparent;
        }

        .nav-link:hover {
            color: var(--text-light);
        }

        .nav-link.active {
            color: var(--accent-blue);
            border-bottom-color: var(--accent-blue);
        }

        /* --- Contenedor Principal y Secciones --- */
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem 1.5rem;
        }
        
        .page-section {
            padding-top: 5rem;
            margin-top: -3.5rem; /* Offset for sticky header */
        }

        /* --- Elementos de Estilo (Tarjetas, Títulos) --- */
        .card {
            background-color: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 0.75rem;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(5px);
        }

        h1, h2, h3, h4 {
            line-height: 1.3;
            margin-bottom: 1rem;
        }
        
        h1 {
            font-size: clamp(2.5rem, 5vw, 3.5rem);
            text-align: center;
            color: var(--text-light);
        }
        
        h2 {
            font-size: clamp(1.8rem, 4vw, 2.5rem);
            color: var(--accent-blue);
            text-align: center;
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 1rem;
        }

        h3 {
            font-size: 1.5rem;
            color: var(--text-light);
        }
        h4 {
            font-size: 1.2rem;
            color: var(--accent-amber);
        }

        .section-subtitle {
            text-align: center;
            max-width: 800px;
            margin: -0.5rem auto 2.5rem auto;
            color: var(--text-muted);
            font-size: 1.1rem;
        }

        /* --- Pestañas de Arquitecturas --- */
        .tabs-container {
            display: flex;
            justify-content: center;
            gap: 0.5rem;
            margin-bottom: 2rem;
            flex-wrap: wrap;
        }

        .tab-button {
            padding: 0.75rem 1.5rem;
            border: 2px solid var(--border-color);
            background-color: transparent;
            color: var(--text-muted);
            font-weight: 600;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .tab-button:hover {
            background-color: var(--bg-card);
            color: var(--text-light);
        }
        .tab-button.active {
            color: var(--text-light);
            background-color: var(--accent-blue);
            border-color: var(--accent-blue);
        }
        .tab-content { display: none; }
        .tab-content.active {
             display: block;
             animation: fadeIn 0.5s ease;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(15px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* --- Acordeones --- */
        .accordion-header {
            width: 100%;
            background-color: rgba(255, 255, 255, 0.05);
            border: none;
            padding: 1rem;
            color: var(--text-light);
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            text-align: left;
            border-radius: 0.5rem;
            margin-top: 1rem;
            transition: background-color 0.3s;
        }
        .accordion-header:hover {
             background-color: rgba(255, 255, 255, 0.1);
        }
        .accordion-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease-in-out;
            background: rgba(0,0,0,0.2);
            padding: 0 1rem;
            border-radius: 0 0 0.5rem 0.5rem;
        }
        .accordion-content div { padding: 1rem 0; }

        /* --- Gráficos y Tablas --- */
        .chart-container {
            position: relative;
            margin: auto;
            height: 50vh;
            max-height: 450px;
            width: 100%;
            max-width: 550px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1.5rem;
        }
        th, td {
            border: 1px solid var(--border-color);
            padding: 0.75rem 1rem;
            text-align: left;
        }
        th {
            background-color: var(--bg-card);
            font-weight: 600;
        }
        tr:nth-child(even) { background-color: rgba(0,0,0,0.1); }

        /* --- Línea de Tiempo --- */
        .timeline {
            position: relative;
            padding: 2rem 0;
        }
        .timeline::before {
            content: '';
            position: absolute;
            left: 1rem;
            top: 0;
            bottom: 0;
            width: 4px;
            background-color: var(--border-color);
            border-radius: 2px;
        }
        .timeline-item {
            position: relative;
            margin-bottom: 2rem;
            padding-left: 3rem;
        }
        .timeline-item::before {
            content: '';
            position: absolute;
            left: 0.5rem;
            top: 0.25rem;
            width: 1.25rem;
            height: 1.25rem;
            border-radius: 50%;
            background-color: var(--bg-dark);
            border: 4px solid var(--accent-blue);
            transition: transform 0.3s;
        }
        .timeline-item.active::before {
            transform: scale(1.2);
        }
        .timeline-header {
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--accent-blue);
            cursor: pointer;
        }
        .timeline-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease-out, margin-top 0.5s ease-out;
            color: var(--text-muted);
        }
        .timeline-item.active .timeline-content {
            margin-top: 0.5rem;
            max-height: 200px; /* Adjust as needed */
        }
        
        /* --- Elementos Diversos (Analogías, etc.) --- */
        .analogy {
            background: rgba(245, 158, 11, 0.1);
            border-radius: 10px;
            padding: 1.5rem;
            margin: 2rem 0;
            border-left: 4px solid var(--accent-amber);
        }
        .examples-container {
            display: flex; flex-wrap: wrap; gap: 0.5rem; margin-top: 1rem;
        }
        .example-tag {
            background: var(--bg-card); padding: 0.4rem 0.8rem; border-radius: 20px; font-size: 0.9rem;
        }
        .grid-2 { display: grid; gap: 2rem; }

        /* --- Responsividad --- */
        @media (min-width: 768px) {
            .grid-2 { grid-template-columns: repeat(2, 1fr); }
        }
        @media (max-width: 768px) {
            nav { justify-content: space-around; }
            .nav-link { padding: 0.8rem 0.5rem; font-size: 0.9rem; }
        }

    </style>
</head>
<body>

    <header>
        <nav id="navbar">
            <a href="#inicio" class="nav-link active">Inicio</a>
            <a href="#arquitecturas" class="nav-link">Arquitecturas</a>
            <a href="#comparativa" class="nav-link">Comparativa</a>
            <a href="#evolucion" class="nav-link">Evolución y Futuro</a>
            <a href="#conclusion" class="nav-link">Conclusión</a>
        </nav>
    </header>

    <main class="container">

        <section id="inicio" class="page-section">
            <div class="card">
                <h1 style="border-bottom:none; margin-bottom: 2rem;">Análisis de Arquitecturas de Sistemas Operativos</h1>
                <p class="section-subtitle" style="font-size: 1.2rem; margin-top: -1rem;">Una exploración interactiva y unificada de los modelos Monolítico, Jerárquico y Cliente-Servidor.</p>
                <div class="grid-2">
                    <div>
                        <h3>Resumen del Estudio</h3>
                        <p>La estructura interna de un sistema operativo (SO) es un factor determinante en su rendimiento, fiabilidad, seguridad y mantenibilidad. Este análisis explora tres arquitecturas fundamentales: monolítica, jerárquica y cliente-servidor (microkernel). El estudio revela que no existe una estructura universalmente superior; la elección depende de los objetivos específicos del sistema. Las tendencias modernas se inclinan hacia modelos híbridos que buscan combinar lo mejor de cada mundo.</p>
                    </div>
                    <div>
                        <h3>Planteamiento y Fundamentos</h3>
                        <p><strong>Problema:</strong> La falta de una comprensión clara de estas arquitecturas puede llevar a una elección subóptima de SO para una tarea determinada.</p>
                        <p><strong>Pregunta de investigación:</strong> <i>¿Cuáles son las características, ventajas, desventajas e implicaciones prácticas de las estructuras monolítica, jerárquica y cliente-servidor?</i></p>
                        <p><strong>Concepto clave:</strong> La separación entre <strong>Modo Usuario</strong> (restringido) y <strong>Modo Kernel</strong> (privilegiado) es esencial para la protección del sistema, y la comunicación entre ambos se realiza mediante <strong>Llamadas al Sistema</strong>.</p>
                    </div>
                </div>
            </div>
        </section>

        <section id="arquitecturas" class="page-section">
            <h2>Paradigmas Arquitectónicos</h2>
            <p class="section-subtitle">Cada arquitectura ofrece un enfoque único para gestionar los recursos del sistema. Seleccione una pestaña para explorar en profundidad sus principios, ventajas y desventajas.</p>
            
            <div class="tabs-container">
                <button class="tab-button active" data-tab="monolitica">Monolítica</button>
                <button class="tab-button" data-tab="jerarquica">Jerárquica</button>
                <button class="tab-button" data-tab="clienteservidor">Cliente-Servidor (Microkernel)</button>
            </div>

            <div class="card">
                <div id="monolitica" class="tab-content active">
                    <h3>Estructura Monolítica: El Gigante Unificado</h3>
                    <p>Todo el sistema operativo se ejecuta como un único y gran programa en el modo privilegiado (modo kernel). Los componentes como la gestión de procesos, memoria, sistema de archivos y controladores están fuertemente acoplados y se comunican mediante llamadas a funciones directas, lo que maximiza el rendimiento.</p>
                    <div class="analogy">
                        <h4>Analogía: El Taller del Artesano Integral</h4>
                        <p>Imagine un taller donde un único artesano tiene todas sus herramientas a mano. Es increíblemente eficiente porque no pierde tiempo. Sin embargo, si una herramienta falla o el artesano comete un error, todo el trabajo se detiene por completo.</p>
                    </div>
                    <div class="grid-2">
                        <div>
                            <h4 style="color:var(--accent-green);">Ventajas</h4>
                            <ul>
                                <li>🚀 <strong>Alto Rendimiento:</strong> La comunicación interna es extremadamente rápida y eficiente.</li>
                                <li>🧩 <strong>Simplicidad Conceptual:</strong> El modelo es fácil de entender inicialmente, ya que todo está en un solo lugar.</li>
                            </ul>
                            <h4 style="color:var(--accent-red); margin-top:1rem;">Desventajas</h4>
                            <ul>
                                <li>🛡️ <strong>Baja Fiabilidad y Seguridad:</strong> Un error en cualquier componente (p. ej., un controlador) puede hacer caer todo el sistema.</li>
                                <li>🔧 <strong>Difícil de Mantener:</strong> En un código masivo y acoplado, encontrar y corregir errores es una tarea titánica.</li>
                            </ul>
                        </div>
                        <div>
                            <h4>Diagrama Estructural</h4>
                            <div style="font-family: monospace; background: #111; padding: 1rem; border-radius: 8px; text-align: center; border: 1px solid var(--border-color);">
                                <pre>
APLICACIONES (Modo Usuario)
     |
Llamada al Sistema (TRAP)
-----+----------------------
     |
[MODO KERNEL - Espacio Único]
|-----------------------------|
| Gestor   | Gestor   | S.A.  |
| Procesos | Memoria  | Fich. |
|-----------------------------|
|      Controladores          |
|-----------------------------|
     |
-----+----------------------
     |
  HARDWARE</pre>
                            </div>
                        </div>
                    </div>
                    <button class="accordion-header">Ver más detalles y Ejemplos</button>
                    <div class="accordion-content">
                        <div>
                            <h4>El Monolítico Modular Moderno</h4>
                            <p>Sistemas como <strong>Linux</strong> superan las limitaciones del modelo puro mediante <strong>Módulos de Kernel Cargables (LKMs)</strong>. Estos módulos (ej. drivers) se pueden cargar y descargar en tiempo de ejecución. Sin embargo, una vez cargado, un módulo se convierte en parte del kernel, compartiendo el mismo espacio de memoria y privilegios. Por ello, un fallo en un módulo sigue siendo catastrófico.</p>
                            <h4>Ejemplos Notables:</h4>
                            <div class="examples-container">
                                <span class="example-tag">Linux</span>
                                <span class="example-tag">UNIX (Clásico)</span>
                                <span class="example-tag">MS-DOS</span>
                                <span class="example-tag">FreeBSD</span>
                                <span class="example-tag">Solaris</span>
                            </div>
                        </div>
                    </div>
                </div>

                <div id="jerarquica" class="tab-content">
                    <h3>Estructura Jerárquica: El Edificio por Capas</h3>
                    <p>El sistema se organiza en una jerarquía de capas. Cada capa se construye sobre la inferior y solo puede usar los servicios de la capa inmediatamente adyacente, ocultando la complejidad interna. Fue pionera en la abstracción y la ingeniería de software.</p>
                     <div class="analogy">
                        <h4>Analogía: La Jerarquía Corporativa</h4>
                        <p>Pensemos en una gran empresa. Un empleado no puede hablar directamente con el CEO. Debe seguir una cadena de mando (supervisor, gerente, director). Es un sistema ordenado y controlado, pero muy lento e ineficiente para tomar decisiones rápidas.</p>
                    </div>
                    <div class="grid-2">
                        <div>
                            <h4 style="color:var(--accent-green);">Ventajas</h4>
                            <ul>
                                <li>🏗️ <strong>Modularidad y Abstracción:</strong> Facilita la comprensión y el desarrollo al dividir el sistema.</li>
                                <li>🐞 <strong>Facilidad de Depuración:</strong> Permite probar y verificar el sistema capa por capa.</li>
                            </ul>
                            <h4 style="color:var(--accent-red); margin-top:1rem;">Desventajas</h4>
                            <ul>
                                <li>🐢 <strong>Bajo Rendimiento:</strong> Cada llamada que atraviesa múltiples capas añade una sobrecarga significativa.</li>
                                <li>⚙️ <strong>Dificultad de Diseño:</strong> Definir las capas de forma limpia y eficiente es muy difícil.</li>
                            </ul>
                        </div>
                        <div>
                           <h4>Diagrama Estructural</h4>
                            <div style="font-family: monospace; background: #111; padding: 1rem; border-radius: 8px; text-align: center; border: 1px solid var(--border-color);">
                                <pre>
+-------------------------+
| Capa N: Interfaz Usuario|
+-------------------------+
             ↕
+-------------------------+
| Capa N-1: Prg. Usuario |
+-------------------------+
             ↕
+-------------------------+
| Capa 3: Gestión de E/S  |
+-------------------------+
             ...
             ↕
+-------------------------+
| Capa 0: Planif. de CPU  |
+-------------------------+
             ↕
+-------------------------+
|        Hardware         |
+-------------------------+</pre>
                            </div>
                        </div>
                    </div>
                     <button class="accordion-header">Ver más detalles y Ejemplos</button>
                    <div class="accordion-content">
                        <div>
                             <h4>Conceptos Históricos</h4>
                             <p>Aunque menos común en estado puro hoy en día, sus principios de diseño son fundamentales. El <strong>Sistema THE</strong> de Dijkstra es el arquetipo, diseñado para ser matemáticamente demostrable. <strong>MULTICS</strong> usaba "anillos de protección" del hardware para implementar las capas.</p>
                            <h4>Ejemplos Notables:</h4>
                            <div class="examples-container">
                               <span class="example-tag">Sistema THE</span>
                               <span class="example-tag">MULTICS</span>
                               <span class="example-tag">OS/2</span>
                               <span class="example-tag">Windows NT (influencias)</span>
                            </div>
                        </div>
                    </div>
                </div>

                <div id="clienteservidor" class="tab-content">
                    <h3>Estructura Cliente-Servidor (Microkernel)</h3>
                    <p>El kernel se reduce al mínimo absoluto (gestión de memoria, hilos y comunicación entre procesos - IPC). El resto de servicios (sistema de archivos, red, drivers) son procesos de usuario llamados "servidores", que se comunican a través de mensajes.</p>
                    <div class="analogy">
                        <h4>Analogía: La Infraestructura de una Ciudad</h4>
                        <p>La Alcaldia (microkernel) solo gestiona lo esencial: carreteras y direcciones. El resto son empresas privadas (servidores): la eléctrica, la de aguas, etc. Si la empresa de basuras va a la huelga, la ciudad no se paraliza. Es un modelo muy fiable, pero coordinar todo es más lento.</p>
                    </div>
                     <div class="grid-2">
                        <div>
                            <h4 style="color:var(--accent-green);">Ventajas</h4>
                            <ul>
                                <li>🛡️ <strong>Alta Fiabilidad y Seguridad:</strong> Si un servidor falla, no afecta al resto del sistema. Puede reiniciarse.</li>
                                <li>🧩 <strong>Alta Modularidad y Flexibilidad:</strong> Añadir un nuevo servicio es tan simple como crear un nuevo programa.</li>
                            </ul>
                             <h4 style="color:var(--accent-red); margin-top:1rem;">Desventajas</h4>
                            <ul>
                                <li>🐢 <strong>Rendimiento Inferior:</strong> La comunicación mediante mensajes (IPC) añade una sobrecarga significativa.</li>
                                <li>🧠 <strong>Complejidad de Diseño:</strong> Gestionar la comunicación asíncrona entre múltiples servidores es complejo.</li>
                            </ul>
                        </div>
                        <div>
                           <h4>Diagrama Estructural</h4>
                            <div style="font-family: monospace; background: #111; padding: 1rem; border-radius: 8px; text-align: center; border: 1px solid var(--border-color);">
                                <pre>
[MODO USUARIO]
+-----------+ +---------+
| Cliente A | | Cliente B |
+-----------+ +---------+
      \         /
       \       /
+-------------------+
| Servidor Ficheros |
+-------------------+
          ↕ (IPC)
-----+-----------------
     | [MODO KERNEL]
+-------------+
| Microkernel |
+-------------+
     |
-----+-----------------
     |
  HARDWARE</pre>
                            </div>
                        </div>
                    </div>
                    <button class="accordion-header">Ver más detalles y Ejemplos</button>
                    <div class="accordion-content">
                        <div>
                            <h4>El Enfoque Híbrido</h4>
                            <p>Sistemas modernos como <strong>macOS y iOS (con su kernel XNU)</strong> adoptan un enfoque híbrido. Combinan un microkernel (Mach) para la mensajería y la gestión básica, con componentes monolíticos (de BSD) para tareas que demandan alto rendimiento, logrando un equilibrio entre fiabilidad y velocidad.</p>
                            <h4>Ejemplos Notables:</h4>
                            <div class="examples-container">
                               <span class="example-tag">QNX</span>
                               <span class="example-tag">Minix 3</span>
                               <span class="example-tag">Mach</span>
                               <span class="example-tag">L4 Family</span>
                               <span class="example-tag">macOS / iOS (Híbrido)</span>
                               <span class="example-tag">Symbian</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <section id="comparativa" class="page-section">
            <h2>Análisis Comparativo</h2>
            <p class="section-subtitle">No existe una arquitectura "perfecta". La elección implica una compensación entre factores críticos. El gráfico visualiza estas diferencias, y la tabla ofrece un análisis detallado.</p>
            <div class="card">
                <div class="grid-2" style="align-items: center;">
                    <div>
                        <h3>Visualización de Atributos Clave</h3>
                        <p style="text-align:center; font-size: 0.9rem; color: var(--text-muted); margin-bottom: 1rem;">Pase el cursor sobre los criterios en el gráfico para ver el análisis detallado.</p>
                        <div class="chart-container">
                            <canvas id="comparisonRadarChart"></canvas>
                        </div>
                    </div>
                    <div>
                        <h3 id="analysis-title">Análisis Detallado</h3>
                        <p id="analysis-text" style="min-height: 150px; color: var(--text-muted);">Pase el cursor sobre un criterio en el gráfico para ver los detalles aquí.</p>
                    </div>
                </div>
            </div>
            <div class="card">
                <h3>Tabla Comparativa Detallada</h3>
                <div style="overflow-x: auto;">
                    <table>
                        <thead>
                            <tr>
                                <th>Característica</th>
                                <th>Monolítica</th>
                                <th>Jerárquica</th>
                                <th>Microkernel</th>
                                <th>Híbrida</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Rendimiento</strong></td><td>Alto</td><td>Lento</td><td>Bajo-Medio</td><td>Equilibrado</td>
                            </tr>
                            <tr>
                                <td><strong>Seguridad</strong></td><td>Baja</td><td>Media</td><td>Alta</td><td>Media-Alta</td>
                            </tr>
                             <tr>
                                <td><strong>Fiabilidad</strong></td><td>Baja</td><td>Media</td><td>Muy Alta</td><td>Alta</td>
                            </tr>
                            <tr>
                                <td><strong>Modularidad</strong></td><td>Baja</td><td>Alta</td><td>Muy Alta</td><td>Alta</td>
                            </tr>
                            <tr>
                                <td><strong>Mantenibilidad</strong></td><td>Baja</td><td>Alta</td><td>Alta</td><td>Media-Baja</td>
                            </tr>
                             <tr>
                                <td><strong>Complejidad Dev.</strong></td><td>Simple (inicio)</td><td>Compleja</td><td>Alta</td><td>Muy Alta</td>
                            </tr>
                            <tr>
                                <td><strong>Ejemplos</strong></td><td>Linux, UNIX</td><td>THE, Multics</td><td>QNX, Minix 3</td><td>Windows, macOS</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </section>

        <section id="evolucion" class="page-section">
            <h2>Evolución y Futuro</h2>
            <p class="section-subtitle">El diseño de SO ha evolucionado constantemente en respuesta a los avances del hardware y las nuevas demandas. Explore los hitos históricos y las arquitecturas emergentes.</p>
             <div class="grid-2">
                <div class="card">
                    <h3>Hitos Históricos</h3>
                    <div class="timeline">
                        <div class="timeline-item">
                            <h4 class="timeline-header">1960s: Multiprogramación</h4>
                            <div class="timeline-content">Sistemas como CTSS y Multics introducen el tiempo compartido, permitiendo la interacción simultánea de múltiples usuarios y sentando las bases del diseño por capas.</div>
                        </div>
                        <div class="timeline-item">
                            <h4 class="timeline-header">1971: UNIX</h4>
                            <div class="timeline-content">Revoluciona el diseño de SO con su simplicidad, portabilidad y una potente arquitectura monolítica que influyó en generaciones de sistemas.</div>
                        </div>
                        <div class="timeline-item">
                            <h4 class="timeline-header">1982: QNX</h4>
                            <div class="timeline-content">Uno de los primeros y más exitosos microkernels comerciales, demostrando la viabilidad del modelo para sistemas de tiempo real y de misión crítica.</div>
                        </div>
                         <div class="timeline-item">
                            <h4 class="timeline-header">1993: Windows NT</h4>
                            <div class="timeline-content">Introduce una arquitectura híbrida, combinando la velocidad monolítica con la modularidad de los subsistemas, sentando las bases para las versiones modernas de Windows.</div>
                        </div>
                         <div class="timeline-item">
                            <h4 class="timeline-header">2007: iOS & Android</h4>
                            <div class="timeline-content">El auge de los SO móviles (basados en kernels híbridos y monolíticos modificados) redefine la interacción y optimiza los sistemas para la eficiencia energética y la computación táctil.</div>
                        </div>
                    </div>
                </div>
                <div class="card">
                    <h3>Tendencias Emergentes</h3>
                    <button class="accordion-header">Exokernels</button>
                    <div class="accordion-content">
                        <div>Un enfoque radical que minimiza la abstracción del kernel, trasladando la gestión de recursos a las aplicaciones. El kernel solo se encarga de la multiplexación segura del hardware, ofreciendo un rendimiento potencial extremo a costa de una mayor complejidad.</div>
                    </div>
                    <button class="accordion-header">Unikernels</button>
                    <div class="accordion-content">
                        <div>Sistemas altamente especializados donde las bibliotecas del SO se enlazan con la aplicación para formar una imagen de máquina única y mínima. Eliminan la separación usuario/kernel, ofreciendo seguridad y rendimiento superiores para microservicios, IoT y computación sin servidor.</div>
                    </div>
                     <button class="accordion-header">Sistemas Operativos en la Nube (Cloud OS)</button>
                    <div class="accordion-content">
                        <div>No es un SO tradicional, sino un entorno que abstrae, agrupa y gestiona recursos escalables (cómputo, almacenamiento) a través de la nube, utilizando virtualización y automatización para ofrecer servicios bajo demanda.</div>
                    </div>
                    <button class="accordion-header">Impacto de la Inteligencia Artificial</button>
                    <div class="accordion-content">
                        <div>La IA se integra en el SO para optimizar proactivamente el rendimiento (ej. planificación de procesos, gestión de energía) y mejorar la interacción del usuario a través de asistentes inteligentes y automatización de tareas.</div>
                    </div>
                </div>
             </div>
        </section>

        <section id="conclusion" class="page-section">
            <h2>Conclusiones y Recomendaciones</h2>
            <p class="section-subtitle">No existe una estructura "ganadora" universal. La elección depende críticamente de los requisitos no funcionales del sistema objetivo.</p>
            <div class="card">
                <div class="grid-2">
                    <div>
                        <h3>El Trade-Off Fundamental</h3>
                        <p>El dilema central en el diseño de arquitecturas de SO es casi siempre <strong>Rendimiento vs. Fiabilidad y Modularidad</strong>.</p>
                        <ul>
                            <li><strong style="color:var(--accent-red)">Monolítica:</strong> Prioriza el rendimiento por encima de todo.</li>
                            <li><strong style="color:var(--accent-blue)">Jerárquica:</strong> Menos común en estado puro hoy, pero sus principios de abstracción influyen en SOs modernos.</li>
                            <li><strong style="color:var(--accent-green)">Cliente-Servidor:</strong> Prioriza la fiabilidad, seguridad y flexibilidad, a costa de un cierto impacto en el rendimiento.</li>
                            
                        </ul>
                    </div>
                    <div>
                        <h3>Recomendaciones Prácticas</h3>
                        <p>Basado en el análisis, se sugiere:</p>
                        <ol style="list-style-position: inside; padding-left: 1rem;">
                            <li>Para sistemas de <strong>misión crítica</strong> (automotriz, aviónica, médico), evaluar arquitecturas basadas en microkernel como QNX o L4.</li>
                            <li>Para <strong>desarrollo de nuevos servicios o drivers</strong>, aprovechar al máximo la modularidad (LKMs en Linux, subsistemas en Windows) para aislar el desarrollo y mejorar la mantenibilidad.</li>
                            <li>Para <strong>servidores y computación de alto rendimiento</strong> donde la velocidad es primordial, el modelo monolítico modular (Linux) sigue siendo el estándar de la industria.</li>
                        </ol>
                    </div>
                </div>
            </div>
        </section>

    </main>
    
    <footer style="text-align: center; padding: 2rem; margin-top: 2rem; color: var(--text-muted); border-top: 1px solid var(--border-color);">
        <p>Unidad N° 3: Estructuras de Sistemas Operativos | Creado por Ing. Ronald Sierra</p>
        <p>&copy; 2025 - Experiencia Interactiva de Aprendizaje.</p>
    </footer>

    <script>
    document.addEventListener('DOMContentLoaded', () => {

        // --- Navegación por Scroll ---
        const navLinks = document.querySelectorAll('.nav-link');
        const sections = document.querySelectorAll('.page-section');
        const onScroll = () => {
            let current = 'inicio';
            sections.forEach(section => {
                const sectionTop = section.offsetTop;
                if (window.pageYOffset >= sectionTop - 150) {
                    current = section.getAttribute('id');
                }
            });
            navLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href').substring(1) === current) {
                    link.classList.add('active');
                }
            });
        };
        window.addEventListener('scroll', onScroll);
        onScroll(); // Initial check

        // --- Lógica de Pestañas (Tabs) ---
        const tabButtons = document.querySelectorAll('.tab-button');
        const tabContents = document.querySelectorAll('.tab-content');
        tabButtons.forEach(button => {
            button.addEventListener('click', () => {
                tabButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                tabContents.forEach(content => {
                    content.classList.remove('active');
                });
                document.getElementById(button.dataset.tab).classList.add('active');
            });
        });
        
        // --- Lógica de Acordeones ---
        const accordionHeaders = document.querySelectorAll('.accordion-header');
        accordionHeaders.forEach(header => {
            header.addEventListener('click', () => {
                const content = header.nextElementSibling;
                if (content.style.maxHeight) {
                    content.style.maxHeight = null;
                } else {
                    content.style.maxHeight = content.scrollHeight + 'px';
                }
            });
        });

        // --- Lógica de Línea de Tiempo ---
        const timelineItems = document.querySelectorAll('.timeline-item');
        timelineItems.forEach(item => {
            const header = item.querySelector('.timeline-header');
            const content = item.querySelector('.timeline-content');
            header.addEventListener('click', () => {
                item.classList.toggle('active');
                 if (item.classList.contains('active')) {
                    content.style.maxHeight = content.scrollHeight + 'px';
                } else {
                    content.style.maxHeight = null;
                }
            });
        });

        // --- Lógica del Gráfico de Radar (Chart.js) ---
        const radarCtx = document.getElementById('comparisonRadarChart').getContext('2d');
        const analysisTitle = document.getElementById('analysis-title');
        const analysisText = document.getElementById('analysis-text');

        const radarData = {
            labels: ['Rendimiento', 'Fiabilidad', 'Seguridad', 'Modularidad', 'Mantenibilidad', 'Flexibilidad'],
            datasets: [
                {
                    label: 'Monolítica',
                    data: [5, 1, 1, 2, 1, 2],
                    borderColor: 'rgba(239, 68, 68, 1)',
                    backgroundColor: 'rgba(239, 68, 68, 0.2)',
                    pointBackgroundColor: 'rgba(239, 68, 68, 1)',
                },
                {
                    label: 'Jerárquica',
                    data: [2, 3, 3, 4, 4, 3],
                    borderColor: 'rgba(59, 130, 246, 1)',
                    backgroundColor: 'rgba(59, 130, 246, 0.2)',
                    pointBackgroundColor: 'rgba(59, 130, 246, 1)',
                },
                {
                    label: 'Cliente-Servidor',
                    data: [3, 5, 5, 5, 5, 5],
                    borderColor: 'rgba(34, 197, 94, 1)',
                    backgroundColor: 'rgba(34, 197, 94, 0.2)',
                    pointBackgroundColor: 'rgba(34, 197, 94, 1)',
                }
            ]
        };

        const analysisContent = {
            Rendimiento: "El modelo monolítico es el claro ganador. La ausencia de fronteras internas permite una comunicación sin sobrecargas, mientras que los microkernels pagan un precio en latencia por cada servicio solicitado debido a la comunicación entre procesos (IPC).",
            Fiabilidad: "El microkernel es el líder indiscutible. La capacidad de aislar un fallo en un servidor (como un driver) y reiniciarlo sin afectar al resto del sistema es una ventaja monumental para sistemas que deben funcionar ininterrumpidamente.",
            Seguridad: "Siguiendo la lógica de la fiabilidad, el microkernel ofrece una superficie de ataque mucho menor en modo privilegiado. Comprometer un servidor no es lo mismo que comprometer el kernel completo. El principio de 'mínimo privilegio' es clave.",
            Modularidad: "Tanto la estructura jerárquica como la de cliente-servidor fueron diseñadas para mejorar la modularidad. Dividir el problema en partes más pequeñas y bien definidas (capas o servidores) es una estrategia probada para gestionar la complejidad.",
            Mantenibilidad: "Las arquitecturas por capas y cliente-servidor facilitan la depuración y modificación aislada de sus componentes. El modelo monolítico, incluso con módulos, sigue siendo un desafío por su código masivo y acoplado.",
            Flexibilidad: "El modelo cliente-servidor es el más flexible, permitiendo añadir, eliminar o actualizar servicios dinámicamente sin reiniciar el kernel. El modelo monolítico es más rígido, aunque los módulos le otorgan cierta flexibilidad."
        };

        new Chart(radarCtx, {
            type: 'radar',
            data: radarData,
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    r: {
                        angleLines: { color: 'rgba(255, 255, 255, 0.2)' },
                        grid: { color: 'rgba(255, 255, 255, 0.2)' },
                        pointLabels: {
                            font: { size: 14, weight: 'bold' },
                            color: '#f3f4f6' // var(--text-light)
                        },
                        ticks: {
                            display: false, beginAtZero: true, max: 5, stepSize: 1,
                            backdropColor: 'transparent'
                        }
                    }
                },
                plugins: {
                    legend: {
                        position: 'top',
                        labels: { font: { size: 14 }, color: '#f3f4f6' }
                    },
                    tooltip: { enabled: true }
                },
                onHover: (event, chartElement) => {
                   if(chartElement.length > 0) {
                       const index = chartElement[0].index;
                       const label = radarData.labels[index];
                       if(analysisContent[label]){
                           analysisTitle.innerText = `Análisis de: ${label}`;
                           analysisText.innerText = analysisContent[label];
                       }
                   } else {
                       analysisTitle.innerText = `Análisis Detallado`;
                       analysisText.innerText = `Pase el cursor sobre un criterio en el gráfico para ver los detalles aquí.`;
                   }
                }
            }
        });
    });
    </script>
</body>
</html>
